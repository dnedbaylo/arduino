// tidalSeq v0.44

/*
      this is a drum probability sequencer. preset patterns control probability of drum playing
   tide level goes up and down - the lower this is, the more likely drums are to play

   normal mode: pots control tide(probability) & swell (randomness) for each channel
   euclidian mode: tidal pot controls proportion of 1s (numerator), so upping tide plays more drums , swell controls denominator (number of beats). buttons work same

  5 buttons:
  <- cue / (lastPattern) / ^lastGlobal^
  shuffle / (randomise) / likeGlobal
  cue -> / (nextPattern) / ^nextGlobal^
  channel / -------- / ^mode^
  shift / (undo)

  shift & turning clock div sets it for just that channel. latch for original setting

  cue shifts current beat for that channel 1 back or forward. last & next Pattern scroll through that channel patterns
  shuffle current pattern. randomise next pattern of maxlength. likeGlobal saves all current settings.
  last & next Global restore everything for all channels. pots latched (flash while turning) until turned to normal point (? global setting)
  mode toggles between tidal & euclidian.

  LEDS for normal mode: 0-- / -0- / --0, euclidian mode: 0-0, -0-



*/

// jumped from 0.21 as hardware done now
// 0.31 changed to single switches
// 0.33 and change react to single switches
// 0.34 more switch issues,
// 0.35 added euclid function.
// 0.36 pulldowns on switches sorted, switch code tweaked.
// 0.37 added LEDs to outputs. sorted out pot code - looking at tide not tidePot for pot changes. doh!
// 0.38 flashes working now
// 0.39 checked shuffle works, etc
// 0.40 sorted out storm affecting shuffle. nice, now - glitch function.
// 0.41 retrieve function working now
// 0.42 buttons changed
// 0.44 not tested, in norfolk, added euclidian mode

// need to check buttosn & randomise function etc
// likes need to be global

// if you enlarge barLength in euclidian mode, should keep same proportion of beats in that loop, or same number across longer? which is more interesting musically?

// still check retrieve

// do minus tide & swell work?
// change clock to switchable so doesn't start if turn off clock signal - short press turns on & off clock, long press does euclid?
// copy prevLiked - nextLiked functions
// one day: save current settings in EEPROM.

// user settable variables
boolean internalClock = true; // default is internal clock
const int TURN_INT_CLOCK_ON_TIME = 10000; // time in ms without a clock signal before int clock restarts
const byte MAX_CLOCK_DIVISOR = 8; // number of clock signals before a trigger issued
const int MIN_TEMPO = 20;
const int MAX_TEMPO = 254;
const int TRIG_LENGTH = 5; // length in ms of outgoing triggers. must be less than min clock period
const int DEBOUNCE_TIME = 100; // debouncing switches - length of press needed to not be a bounce
const int LONG_HOLD_TIME = 1000;  // more this is a long press
const int VERY_SHORT_FLASHES = 30; // ms between on & off flashes
const int MEDIUM_FLASHES = 100;
const int SLOW_FLASH = 300;
const int MAX_LIKES = 16; // might run out of memory if this goes high
const int SWEET_SPOT = 75;
const int MAX_STORM = 50; // 50 gives variance of around 5 in waves

boolean debug = true;


// best not to change these
const int MAX_PATTERN_LENGTH = 16;

const int POT_HYSTERESIS = 30;
const byte CHANNELS = 3;
const byte PATTERNS = 16;
const byte MODES = 2; // tidal & euclidian


// patterns - do change these
const char* pattern[CHANNELS][PATTERNS] = { // { {BD, BD etc}, {SD}, {HH} } // higher numbers more likely to play
  { "9173827491738787", "81458276", "865773562222", "865773562222",
    "81458276",  "489082038", "384793874", "57652720",
    "91367457156", "222222", "26453647", "918273645"
  },
  { "81458276",  "489082038", "384793874",  "12345678",
    "234567", "98765432", "86421357"
  },
  { "865773562222", "2376489", "3294729", "63636374",
    "3294729", "63636374", "0000000", "000000",
    "00000000", "000000000"
  },
};


#define EUCLID 1
#define NORMAL 0
const byte BD = 0;
const byte snare = 1;
const byte HH = 2;

// setup pins
// 14 digital pins - 5 switches (3, channel, shift) , clock in, 3 trigs out, 3 LEDS
// 8 analog ins - 3 chs x tide & swell, 1 for clock divider, 1 for storm (overall swell)

const byte TIDE_PIN[] = {A5, A6, A7}; // read from jacks / normalled pots
const byte SWELL_PIN[] = {A0, A1, A2}; // or syntax is #define KNOB0_PIN A0
const byte CLOCK_RATE_PIN = A3;
const byte STORM_PIN = A4;
// pins 0(Rx) & 1(Tx) could be used for MIDI
const byte CLOCK_IN_PIN = 2;
const byte TRIG_OUT_PIN[] = {3, 12, 11};
const byte LED_OUT_PIN[] = {4, 5, 6};
const byte LEFT_SW_PIN = 7; // {4, 5, 6};
const byte MID_SW_PIN = 8; // {7, 8, 9};
const byte RIGHT_SW_PIN = 9; // {10, 11, 12};
const byte CHANNEL_SW_PIN = 13;
const byte SHIFT_SW_PIN = 10;

const float HIGH_TIDE = 9.2;
const float LOW_TIDE = 0.9;


// working variables

float storm;
boolean necklace[CHANNELS][16];
int numberOfPatterns[CHANNELS];
int tempo, clockPot, oldClockPot;
byte currentChannel = 0;
String storeLike[CHANNELS][MAX_LIKES]; // stores tide, swell settings as String with ~ between
float clockPeriod; // gap between internal clock signals
boolean trigger = false;
long lastTrigger = millis();
long writeStartTime[CHANNELS];
long leftSwOnTime, midSwOnTime, rightSwOnTime, channelSwOnTime, modeSwOnTime;
boolean lastLeftReading, lastMidReading, lastRightReading, lastChannelSelectReading, lastShiftReading;
boolean clockIn;
boolean oldClockIn = false;
long areClocksIncoming;
long clockInTime = millis();
int clockNumber = 0;
byte clockDivisor = 1; // default, set by analogRead CLOCK_RATE_PIN
String temp;
String thisChar;
float wave[CHANNELS];
int currentPattern[CHANNELS][MAX_PATTERN_LENGTH]; // 2d array of ints for current pattern for each channel
int currentPatternLength[CHANNELS];
int currentPatternNumber[CHANNELS] = {0, 0, 0}; // which pattern it is in patterns[ch][?] array
byte currentLike[CHANNELS] = {0, 0, 0};
byte nextLike[CHANNELS] = {0, 0, 0};
byte currentStep[CHANNELS] = {0, 0, 0};
int tidePot[CHANNELS] = {1000, 575, 575}; // will be 0-1023, so 3 is 3 * 115 = 345, goes backwards so turning to R lowers tide ie more beats, but inverted!
int tidePotNew[CHANNELS], swellPot[CHANNELS], swellPotNew[CHANNELS];
float tide[CHANNELS];
int swell[CHANNELS];
int lastPattern[CHANNELS][MAX_PATTERN_LENGTH];
int lastPatternLength[CHANNELS], lastTide[CHANNELS], lastSwell[CHANNELS];
int tempTide[CHANNELS], tempSwell[CHANNELS];
int tempCurrentPattern[CHANNELS][MAX_PATTERN_LENGTH];
int tempCurrentPatternLength[CHANNELS];
int lastCurrentPattern[CHANNELS][MAX_PATTERN_LENGTH];
byte highestValidLikedPattern[CHANNELS] = {0, 0, 0};
boolean shuffleSw, randomisePatternSw , likeSw, prevLikedSw, nextLikedSw, prevPatternSw, nextPatternSw, modeSw;
boolean undo = false;
boolean LEDstate[CHANNELS] = {0, 0, 0};
int LEDflashes[CHANNELS];
long LEDtime[CHANNELS];
long lastLEDtransition[CHANNELS];
byte cue[CHANNELS]; // controls shift

// euclidian mode
byte mode[CHANNELS];
int barLength[CHANNELS], oldBarLength[CHANNELS];
int hits[CHANNELS], oldHits[CHANNELS];
const int MIN_BAR = 2;
const int MAX_BAR = 12;







void setup() {
  Serial.begin(9600);


  pinMode(CLOCK_IN_PIN, INPUT);
  for (int i = 0; i < CHANNELS; i ++) {
    pinMode(TRIG_OUT_PIN[i], OUTPUT);
  }

  // derive number of lengths
  for (int ch = 0; ch < CHANNELS; ch ++) {
    for (int j = 0; j < PATTERNS; j ++) {
      temp = pattern[ch][j]; // converts to String
      if (temp.length() > MAX_PATTERN_LENGTH) {
        Serial.println("error in pattern");
        Serial.println(ch);
        Serial.println(j);
      }
      numberOfPatterns[ch] = j; // save number of patterns for each channel
      if (temp.toInt() == 0) { // enough now
        break;
      }
    }
    temp = pattern[ch][currentPatternNumber[ch]]; // starting pattern - this converts to String
    extractPattern(temp, ch); // reads String into array of integers, currentPattern[ch][note], with length currentBDPatternLength[ch]
  }

  flashLED(0, 3, 300); // channel, no of times, ms between
  flashLED(1, 3, 300);
  flashLED(2, 3, 300);
  if (true && debug) {
    for (int i = 0; i < CHANNELS; i ++) {
      printPattern(i);
    }
  }
} // end setup

// ************** main loop start ********************
void loop() {

  // storm = map(analogRead(STORM_PIN), 0, 1023, 0, MAX_STORM);

  // just for testing
  storm = map(analogRead(SWELL_PIN[2]), 0, 1023, 0, MAX_STORM) * 1.0;
  clockDivisor = int(map(analogRead(CLOCK_RATE_PIN), 0, 1023, 0, MAX_CLOCK_DIVISOR));

  // read clock pin - updates clockNumber if new signal
  clockIn = !(digitalRead(CLOCK_IN_PIN)); // incoming clock inverted ie clock signals are low
  if (clockIn) {
    internalClock = false;
    areClocksIncoming = millis(); // start 'turn off' timer whenever clock signal incoming
  }
  if (!internalClock) {
    if ((clockIn) && (!oldClockIn) && (millis() > (clockInTime + DEBOUNCE_TIME))) { // new clock signal
      clockNumber ++;
      oldClockIn = true;
      clockInTime = millis();
    } else if (!clockIn) {
      oldClockIn = false;
    }
    // look for new clock signal, and check clock Divisor, issue new trigger if appropriate
    if (clockNumber >= clockDivisor) {
      trigger = true;
      clockNumber = 0;
    }
    if (millis() > areClocksIncoming + TURN_INT_CLOCK_ON_TIME) { // no clock signal for ages, revert to internal clock
      internalClock = true;
    }
  } else if (internalClock) {
    clockPot = analogRead(CLOCK_RATE_PIN);
    if (abs(clockPot - oldClockPot) > (POT_HYSTERESIS)) {
      oldClockPot = clockPot;
      tempo = map(clockPot, 0, 1023, MIN_TEMPO, MAX_TEMPO);
      clockPeriod = 30000 / tempo; // 2 beats per bpm thus not 60000
      if (debug) {
        Serial.print("new tempo is: ");
        Serial.println(tempo);
      }
    }
  }
  if (millis() > (lastTrigger + clockPeriod)) {
    lastTrigger = millis();
    trigger = true;
  }

  checkSwitches();  // read switches - sets randomise, back, next booleans, current channel

  // step through patterns
  for (int ch = 0; ch < CHANNELS; ch ++) {

    currentStep[ch] += cue[ch]; // process cue changes
    cue[ch] = 0;

    checkPots(ch);

    // set swell / bar length
    if (mode[ch] == NORMAL) {
      if (swellPot[ch] < (512 - SWEET_SPOT)) {
        wave[ch] = 0 - (random(map(swellPot[ch], 0, (512 - SWEET_SPOT), HIGH_TIDE * storm, 0)) / 100.0);
      } else if (swellPot[ch] > (512 + SWEET_SPOT)) {
        wave[ch] = (random(map(swellPot[ch], (512 + SWEET_SPOT), 1023, 0, HIGH_TIDE * storm)) / 100.0); // storm ups level of glitchiness - 0 up to 50 is good giving +- 5 or so
      } else {
        wave[ch] = 0.0; // in sweet middle spot
      }
    } else if (mode[ch] == EUCLID) {
      barLength[ch] = map(swellPot[ch], 0, 1023, MIN_BAR, MAX_BAR);
      if (barLength[ch] != oldBarLength[ch]) {
        oldBarLength[ch] = barLength[ch];
        // recalculate euclidian ratio
        euclid(ch, hits[ch], barLength[ch]);
        // & copy result into current pattern
        for (int i = 0; i < barLength[ch]; i ++) {
          currentPattern[ch][i] = necklace[ch][i];
        }
        currentPatternLength[ch] = barLength[ch];

        if (true && debug) {
          printPattern(ch);
        }
      }
    }

    // set tides / hits
    if (mode[ch] == NORMAL) {
      tide[ch] = map(tidePot[ch], 0, 1023, LOW_TIDE, HIGH_TIDE * 100.0) / 100.0; // INVERTED. set tide height (above 9 ie play nothing, below 1 so play everything excepts 0s)
    } else if (mode[ch] == EUCLID) {
      hits[ch] = map(tidePot[ch], 0, 1023, 0, barLength[ch]);
      if (hits[ch] != oldHits[ch]) {
        oldHits[ch] = hits[ch];
        // recalculate euclidian ratio
        euclid(ch, hits[ch], barLength[ch]);
        // & copy result into current pattern
        for (int i = 0; i < barLength[ch]; i ++) {
          currentPattern[ch][i] = necklace[ch][i];
        }
        currentPatternLength[ch] = barLength[ch];

        if (true && debug) {
          printPattern(ch);
        }
      }
    }

    // deal with triggers
    if (trigger) {  // incoming pulse, so look if need to play
      currentStep[ch] ++; // next step
      if (currentStep[ch] >= currentPatternLength[ch]) { // & loop around
        currentStep[ch] = 0;
      }
      if (debug && ch == 0) {
        Serial.print(" tide = ");
        Serial.print(tide[0]);
        Serial.print(" wave = ");
        Serial.println(wave[0]);
      }

      if (mode[ch] = NORMAL) {
        if ((tide[ch] + wave[ch]) < currentPattern[ch][currentStep[ch]]) { // play if tide out and wave is low
          play(ch);
        }
      } else if (mode[ch] = EUCLID) {
        if (currentPattern[ch][currentStep[ch]]) {
          play(ch);
        }
      }

      if (true && debug && (ch == 0)) {         // debug looking at channel 1
        Serial.print(currentPattern[0][currentStep[0]]);
      } else if (ch == 0) {
        Serial.print("-");
      }
    } // end trigger rotuine


    // check & turn off output pins after trig_length ms
    if (millis() > writeStartTime[ch] + TRIG_LENGTH) {
      digitalWrite(TRIG_OUT_PIN[ch], HIGH); // inverted
    }
  } // end per channel stuff
  trigger = false;


  // deal with switches

  if (shuffleSw) { // backup then shuffle current pattern

    saveCurrent(currentChannel);
    for (int i = 0; i < currentPatternLength[currentChannel]; i ++) { // for each value
      int r = random(0, currentPatternLength[currentChannel] - 1 - i); // choose a random number
      int t = currentPattern[currentChannel][r]; // and shuffle the array
      currentPattern[currentChannel][r] = currentPattern[currentChannel][currentPatternLength[currentChannel] - 1 - i];
      currentPattern[currentChannel][currentPatternLength[currentChannel] - 1 - i] = t;
    }
    shuffleSw = false;

    if (debug) {
      Serial.println("shuffle switch");
      printPattern(currentChannel);
    }
  }



  if (likeSw) {      // save current settings - current pattern as numbers in a string, current tide & swell[ch], set latch for both on
    // saves in nextLike, then updates nextLike for next time

    storeLike[currentChannel][nextLike[currentChannel]] = currentPattern[currentChannel][0];  // store numbers in current pattern
    for (int i = 1; i  < currentPatternLength[currentChannel]; i ++) {
      storeLike[currentChannel][nextLike[currentChannel]] += currentPattern[currentChannel][i];
    }
    storeLike[currentChannel][nextLike[currentChannel]] += "#";
    storeLike[currentChannel][nextLike[currentChannel]] += tide[currentChannel];
    storeLike[currentChannel][nextLike[currentChannel]] += "~";
    storeLike[currentChannel][nextLike[currentChannel]] +=  swell[currentChannel];
    storeLike[currentChannel][nextLike[currentChannel]] += "&";
    storeLike[currentChannel][nextLike[currentChannel]] +=  currentPatternLength[currentChannel];
    likeSw = false;

    nextLike[currentChannel] ++;
    if (nextLike[currentChannel] > MAX_LIKES) {
      nextLike[currentChannel] = 0;
      flashLED(currentChannel, 5, SLOW_FLASH); // warn that we're back to beginning
    }
    if (nextLike[currentChannel] > highestValidLikedPattern[CHANNELS]) {
      highestValidLikedPattern[currentChannel] = nextLike[currentChannel];
    }

    if (true && debug) {
      Serial.println("like switch");     // see storeString test for a way of saving lots of settings as a single string
      Serial.print(" saved in  ");
      Serial.println(nextLike[currentChannel]);
      Serial.print("highest Liked");
      Serial.println(highestValidLikedPattern[currentChannel]);
      Serial.println(storeLike[currentChannel][nextLike[currentChannel]]);
    }
  }

  if (prevLikedSw) { // retrieve next stored "liked" setting - pattern, tide & swell (latched)
    // copy below
    prevLikedSw = false;
  }


  if (nextLikedSw) { // retrieve next stored "liked" setting - pattern, tide & swell (latched)

    saveCurrent(currentChannel); // backup current settings
    currentLike[currentChannel] ++;
    if (currentLike[currentChannel] >= highestValidLikedPattern[currentChannel]) {
      currentLike[currentChannel] = 0; // loop around - no going back on recovering likes
    }
    if (true && debug) {
      Serial.print(" retrieve liked no:  ");
      Serial.println(currentLike[currentChannel]);
      //      Serial.println(storeLike[currentChannel][currentLike[currentChannel]]);
    }
    retrieveLiked(currentChannel, currentLike[currentChannel]);
    nextLikedSw = false;
    //    patternChanged[currentChannel] = false;

    if (debug) {
      Serial.println("next switch");
      printPattern(currentChannel);
    }
  }


  if (nextPatternSw) {

    saveCurrent(currentChannel); // backup current settings
    currentPatternNumber[currentChannel] ++;
    if (currentPatternNumber[currentChannel] > numberOfPatterns[currentChannel]) {
      nextPatternSw = false;
      currentPatternNumber[currentChannel] = numberOfPatterns[currentChannel]; // don't roll around
    }
    if (nextPatternSw) {
      temp = pattern[currentChannel][currentPatternNumber[currentChannel]]; // converts to String
      extractPattern(temp, currentChannel); // reads String into array of integers, currentPattern[currentChannel][note], with length currentPatternLength[currentChannel]
      nextPatternSw = false;
    }

    if (debug) {
      Serial.println("next pattern switch");
      printPattern(currentChannel); // debug
    }
  }


  if (prevPatternSw) {

    saveCurrent(currentChannel); // backup current settings
    currentPatternNumber[currentChannel] --;
    if (currentPatternNumber[currentChannel] < 0 ) {
      prevPatternSw = false; // end here
      currentPatternNumber[currentChannel] = 0 ; //numberOfPatterns[currentChannel];
    }

    if (prevPatternSw) {
      temp = pattern[currentChannel][currentPatternNumber[currentChannel]]; // converts to String
      extractPattern(temp, currentChannel); // reads String into array of integers, currentPattern[currentChannel][note], with length currentPatternLength[currentChannel]
      prevPatternSw = false;
    }

    if (debug) {
      Serial.println("last pattern switch");
      printPattern(currentChannel); // debug
    }
  }

  if (undo) {

    //loads previous settings into temporary memory
    tempTide[currentChannel] = lastTide[currentChannel];
    tempSwell[currentChannel] = lastSwell[currentChannel];
    for (int i = 0; i < lastPatternLength[currentChannel]; i ++) {
      tempCurrentPattern[currentChannel][i] = lastPattern[currentChannel][i];
    }
    tempCurrentPatternLength[currentChannel] = lastPatternLength[currentChannel];

    // backup current settings, so back, back gets back to original place
    saveCurrent(currentChannel);

    // & restore last saved settings from memory into current pattern
    tide[currentChannel] = tempTide[currentChannel]; // loads last saved now
    swell[currentChannel] = tempSwell[currentChannel];
    currentPatternLength[currentChannel] = tempCurrentPatternLength[currentChannel];
    for (int i = 0; i < currentPatternLength[currentChannel]; i ++) {
      currentPattern[currentChannel][i] = tempCurrentPattern[currentChannel][i];
    }

    undo = false;

    if (debug) {
      Serial.println("undo switch");
      printPattern(currentChannel);
    }

  }


  if (modeSw) {

    mode[currentChannel] ++;
    if (mode[currentChannel] >= MODES) {
      mode[currentChannel] = 0;
    }
    modeSw = false;

    if (true && debug) {
      Serial.println("mode switch");
      Serial.print("mode changed to ");
      Serial.println(mode[currentChannel]);
    }

  }


  if (randomisePatternSw) {

    saveCurrent(currentChannel);
    for (int i = 0; i < MAX_PATTERN_LENGTH; i ++) {
      currentPattern[currentChannel][i] = int(random(LOW_TIDE, HIGH_TIDE));
    }
    currentPatternLength[currentChannel] = MAX_PATTERN_LENGTH;
    randomisePatternSw = false;

    if (debug) {
      Serial.println("randomise");
      printPattern(currentChannel);
    }
  }


  // housekeeping
  updateLEDs();

} // end loop

// *****************  end main loop *****************

void retrieveLiked(int ch, int no) {
  // load settings from StoreLike[ch][no]
  int hash = storeLike[ch][no].indexOf('#'); // position of hash
  int tilde = storeLike[ch][no].indexOf('~');
  int ampersand = storeLike[ch][no].indexOf('&');
  //  Serial.println("");
  for (int i = 0; i < hash; i ++) {
    currentPattern[ch][i] = int((storeLike[ch][no].charAt(i))) - 48;
    Serial.print(int((storeLike[ch][no].charAt(i))) - 48);
  }
  // currentPatternNumber[ch] = (storeLike[ch][currentLike[ch]].substring(0, hash)).toInt();
  tide[ch] = 0 - storeLike[ch][no].substring(hash + 1, tilde).toInt(); // gives - number so latched
  swell[ch] = 0 - storeLike[ch][no].substring(tilde + 1, ampersand).toInt();
  //  currentPatternLength[ch] = storeLike[ch][no].substring(ampersand + 1, storeLike[ch][no].length()).toInt();
  currentPatternLength[ch] = hash;
  Serial.print(" length = ");
  Serial.println(currentPatternLength[ch]);

}
/* // pre v0.43
  void retrieveLiked(int ch, int currentLike) {
  // load settings from StoreLike[ch][no]
  int hash = storeLike[currentChannel][currentLike[currentChannel]].indexOf('#'); // position of hash
  int tilde = storeLike[currentChannel][currentLike[currentChannel]].indexOf('~');
  int ampersand = storeLike[currentChannel][currentLike[currentChannel]].indexOf('&');
  for (int i = 0; i < hash; i ++) {
    currentPattern[currentChannel][i] = int((storeLike[currentChannel][currentLike[currentChannel]].charAt(i)));
  }
  // currentPatternNumber[ch] = (storeLike[ch][currentLike[ch]].substring(0, hash)).toInt();
  tide[currentChannel] = 0 - storeLike[currentChannel][currentLike[currentChannel]].substring(hash + 1, tilde).toInt(); // gives - number so latched
  swell[currentChannel] = 0 - storeLike[currentChannel][currentLike[currentChannel]].substring(tilde + 1, ampersand).toInt();
  currentPatternLength[currentChannel] = storeLike[currentChannel][currentLike[currentChannel]].substring(ampersand + 1, storeLike[currentChannel][currentLike[currentChannel]].length()).toInt();

  }
*/

void updateLEDs() {
  for (int ch = 0; ch < CHANNELS; ch ++) {
    if (LEDflashes[ch] != 0) {
      if (millis() > lastLEDtransition[ch] + LEDtime[ch]) {
        LEDstate[ch] = ! LEDstate[ch];
        LEDflashes[ch] --;
        lastLEDtransition[ch] = millis();
        if (false && debug) {
          Serial.print("LEDflashes on channel ");
          Serial.println(ch);
          Serial.println(LEDflashes[ch]);
        }
      }
    } else if (LEDflashes[ch] == 0) { // back to selected channel
      if (ch == currentChannel) {
        LEDstate[ch] = true;
      } else {
        LEDstate[ch] = false;
      }
    }
    digitalWrite(LED_OUT_PIN[ch], LEDstate[ch]);
  }
}

void flashLED(byte channel, int times, long flashDuration) {
  if (channel != currentChannel) {
    LEDstate[channel] = false;
  } else {
    LEDstate[channel] = true;
  }
  LEDflashes[channel] = (times * 2);
  LEDtime[channel] = flashDuration;
  lastLEDtransition[channel] = millis();
}


void extractPattern(String incoming, int channel) {
  // Serial.println("extract Pattern");
  // converts incomign String into array of integers
  for (int i = 0; i < MAX_PATTERN_LENGTH; i ++) {
    currentPattern[channel][i] = 0; // clear array
  }
  currentPatternLength[channel] = incoming.length();
  int spaces = 0;
  for (int j = 0; j < currentPatternLength[channel]; j ++) {
    thisChar = incoming.charAt(j);
    currentPattern[channel][j] = thisChar.toInt();
  }
}

void saveCurrent(int channel) {
  lastPatternLength[channel] = currentPatternLength[channel];
  for (int i = 0; i < lastPatternLength[channel]; i++) {
    lastPattern[channel][i] = currentPattern[channel][i];
  }
  lastTide[channel] = 0 - tide[channel];
  lastSwell[channel] = 0 - swell[channel];
}

void play(int channel) {
  digitalWrite(TRIG_OUT_PIN[channel], LOW); // inverted
  writeStartTime[channel] = millis();
}

void checkPots(int ch) { // ch is channel

  // tidePotNew[ch] = analogRead(TIDE_PIN[ch]);
  // swellPotNew[ch] = analogRead(SWELL_PIN[ch]);

  tidePotNew[ch] = analogRead(SWELL_PIN[ch]);
  // swellPotNew[ch] = analogRead(TIDE_PIN[ch]);
  swellPotNew[0] = analogRead(SWELL_PIN[1]);

  if ((tidePot[ch] < 0) && (abs(tidePotNew[ch] - abs(tidePot[ch])) < POT_HYSTERESIS)) { // near where it should be
    tidePot[ch] = abs(tidePot[ch]); // turn latch off
  }
  if ((tidePot[ch] >= 0) && (abs(tidePotNew[ch] - tidePot[ch]) > POT_HYSTERESIS)) { // pot moved
    tidePot[ch] = tidePotNew[ch];
    if (false && debug) { // debug tide setting
      Serial.print("tide on ch ");
      // Serial.print(ch);
      // Serial.print(" : ");
      Serial.println(map(tidePot[ch], 0, 1023, LOW_TIDE, HIGH_TIDE));
    }
  }


  if ((swellPot[ch] < 0) && (abs(swellPotNew[ch] - abs(swellPot[ch])) < POT_HYSTERESIS)) { // near where it should be
    swellPot[ch] = abs(swellPot[ch]); // turn latch off
  }
  if ((swellPot[ch] >= 0) && (abs(swellPotNew[ch] - swellPot[ch]) > POT_HYSTERESIS)) { // pot moved
    swellPot[ch] = swellPotNew[ch];
    if (false && debug) { // debug swell
      Serial.print("swell on ch ");
      //  Serial.print(ch);
      //  Serial.print(" : ");
      Serial.println(map(swellPot[ch], 0, 1023, LOW_TIDE, HIGH_TIDE)); // wave height
    }
  }
}


void checkSwitches() {

  // channelSw: next channel, (NOT YET DEFINED), ^mode^
  if ((digitalRead(CHANNEL_SW_PIN))  && (!lastChannelSelectReading)) { // 1st press
    channelSwOnTime = millis();
    lastChannelSelectReading = true;
  }
  if ((!digitalRead(CHANNEL_SW_PIN)) && lastChannelSelectReading && (millis() > (channelSwOnTime + DEBOUNCE_TIME))) { // let go after debounce time
    if (millis() < (channelSwOnTime + LONG_HOLD_TIME)) { // let go after short press
      LEDstate[currentChannel] = LOW; // turn off
      currentChannel ++;
      if (currentChannel >= CHANNELS) {
        currentChannel = 0;
      }
      LEDstate[currentChannel] = HIGH; // turn on

      if (true && debug) {
        Serial.print("currentChannel ");
        Serial.println(currentChannel);
      }

    } else if (millis() >= (channelSwOnTime + LONG_HOLD_TIME)) {   // let go after long press
      if (digitalRead(SHIFT_SW_PIN)) { // long hold & shift
        modeSw = true;

      }
    } else { // long hold, not shift
      // NOT YET DEFINED
    }

  }
  if (!(digitalRead(CHANNEL_SW_PIN))) {
    lastChannelSelectReading = false; // let go
  }


  // leftSw: <-cue, prevPattern, ^prevGlobalLiked^
  if ((digitalRead(LEFT_SW_PIN)) && (!lastLeftReading)) {
    leftSwOnTime = millis();
    lastLeftReading = true;
    // any other code to run at start of button press goes here
  }
  if ((LEDflashes[0] >= 0) && (digitalRead(LEFT_SW_PIN)) && (millis() >= (leftSwOnTime + LONG_HOLD_TIME))) {
    flashLED(0, -1, VERY_SHORT_FLASHES); // turn on during long press
  }
  if ((!digitalRead(LEFT_SW_PIN)) && lastLeftReading && (millis() > (leftSwOnTime + DEBOUNCE_TIME))) {
    lastLeftReading = false; // let go

    if (millis() < (leftSwOnTime + LONG_HOLD_TIME)) {  // let go after short press
      //   flashLED(0, 3, MEDIUM_FLASHES);
      cue[currentChannel] --;

    } else if (millis() >= (leftSwOnTime + LONG_HOLD_TIME)) {       // long press
      if (digitalRead(SHIFT_SW_PIN)) { // long hold & shift
        prevLikedSw = true;
        flashLED(0, 5, MEDIUM_FLASHES);
      } else { // long hold not shift
        prevPatternSw = true;
        flashLED(0, 3, MEDIUM_FLASHES);
      }
    }
  }
  if (!(digitalRead(LEFT_SW_PIN))) {
    lastLeftReading = false; // let go
  }


  // midSw: shuffle, (randomise), ^likeGlobal^
  if ((digitalRead(MID_SW_PIN)) && (!lastMidReading)) {
    midSwOnTime = millis();
    lastMidReading = true;
  }
  if ((LEDflashes[1] >= 0) && (digitalRead(MID_SW_PIN)) && (millis() >= (midSwOnTime + LONG_HOLD_TIME))) {
    flashLED(1, -1, VERY_SHORT_FLASHES); // turn on during long press
  }
  if ((!digitalRead(MID_SW_PIN)) && (lastMidReading) && (millis() > (midSwOnTime + DEBOUNCE_TIME))) {
    lastMidReading = false; // let go

    if (millis() < (midSwOnTime + LONG_HOLD_TIME)) { // let go after short press
      shuffleSw = true;
      flashLED(2, 3, MEDIUM_FLASHES);
    } else { //   if (millis() >= (midSwOnTime + LONG_HOLD_TIME)) {  // let go after long press
      if (digitalRead(SHIFT_SW_PIN)) { // long hold & shift
        randomisePatternSw = true;
        flashLED(1, 7, VERY_SHORT_FLASHES);
      } else {
        likeSw = true;
        flashLED(1, 5, MEDIUM_FLASHES);
      }
    }
  }
  if (!(digitalRead(MID_SW_PIN))) {
    lastMidReading = false; // let go
  }


  // rightSw:  cue, (next Pattern), ^nextGlobal^
  if ((digitalRead(RIGHT_SW_PIN)) && (!lastRightReading)) {
    rightSwOnTime = millis();
    lastRightReading = true;
  }
  if ((LEDflashes[2] >= 0) && (digitalRead(RIGHT_SW_PIN)) && (millis() >= (rightSwOnTime + LONG_HOLD_TIME))) {
    flashLED(2, -1, VERY_SHORT_FLASHES); // turn on during long press
  }
  if ((!digitalRead(RIGHT_SW_PIN)) && (lastRightReading) && (millis() > (rightSwOnTime + DEBOUNCE_TIME))) {
    lastRightReading = false; // let go
    if (millis() < (rightSwOnTime + LONG_HOLD_TIME)) {       // short press
      cue[currentChannel] ++;

    } else if (millis() >= (rightSwOnTime + LONG_HOLD_TIME)) {       // long press
      if (digitalRead(SHIFT_SW_PIN)) { // long hold & shift
        nextLikedSw = true;
        flashLED(2, 5, MEDIUM_FLASHES);
      } else { // long but not shift
        nextPatternSw = true;
        flashLED(2, 3, MEDIUM_FLASHES);
      }
    }
  }
  if (!(digitalRead(RIGHT_SW_PIN))) {
    lastRightReading = false; // let go
  }


  // shift (undo) switch
  if ((digitalRead(SHIFT_SW_PIN)) && (!lastShiftReading)) {
    modeSwOnTime = millis();
    lastShiftReading = true;
  }
  if ((!digitalRead(SHIFT_SW_PIN)) && (lastShiftReading) && (millis() > (modeSwOnTime + DEBOUNCE_TIME))) {
    lastShiftReading = false; // let go
    if (millis() < (modeSwOnTime + LONG_HOLD_TIME)) {       // short press
      modeSw = true;
    } else { //    if (millis() >= (modeSwOnTime + LONG_HOLD_TIME)) {       // long press
    }
  }
  if (!(digitalRead(SHIFT_SW_PIN))) {
    lastShiftReading = false; // let go
  }
}


void euclid(int ch, int ones, int onesAndZeroes) {
  float gap = onesAndZeroes / ones; // distance between
  Serial.print("gap is ");
  Serial.println(gap);
  if (ones) {
    necklace[ch][0] = 1; // starts with 1
  } else {
    necklace[ch][0] = 0; // starts with 1
  }
  for (int i = 1; i < (onesAndZeroes); i ++) {
    necklace[ch][i] = 0; // & clear the rest by filling with 0s
  }
  for (int i = 1; i < ones; i ++) {
    necklace[ch][int(ceil(gap * i))] = 1; // round up to nearest integer
  }
  // return necklace[ch][];// does this work?
}
/*
   // v0.44
  void euclid(int ch, float ones, float zeroes) {
  float gap = (ones + zeroes) / ones; // distance between spaces
  necklace[ch][0] = 1; // starts with 1
  for (int i = 1; i < (ones + zeroes); i ++) {
    necklace[ch][i] = 0; // & clear the rest by filling with 0s
  }
  for (int i = 1; i < ones; i ++) {
    necklace[ch][int(ceil(gap * i))] = 1; // round up to nearest integer
  }
  }
*/


// ********** debug *********

void printPattern(int ch) {
  Serial.print("current channel is ");
  Serial.println(ch);
  for (int i = 0; i < currentPatternLength[ch]; i ++) {
    Serial.print(currentPattern[ch][i]);
  }
  Serial.println("");
}





